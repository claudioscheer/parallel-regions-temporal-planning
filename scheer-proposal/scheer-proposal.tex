\documentclass[letterpaper]{article}

\usepackage{aaai}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{tabularx}

\frenchspacing
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\pdfinfo{
/Title (Parallel Regions using a PDDL Formalization)
/Author (Claudio Scheer)}
\setcounter{secnumdepth}{0}  


\begin{document}

\title{Parallel Regions using a PDDL Formalization}
\author{Claudio Scheer\\
  claudio.scheer@edu.pucrs.br\\
  Master's Degree in Computer Science\\
  Pontifical Catholic University of Rio Grande do Sul - PUCRS\\
  Porto Alegre - RS, Brazil\\
}
\maketitle


\begin{abstract}
  \begin{quote}
    Testing whether a region in a program can be run in parallel is not an easy task. This process takes a lot of time and, consequently, finantial resources. As an approach to this problem, this paper proposes formalizing a compiler with PDDL. With this formalization, it will be possible to reduce the identification of a parallel code to a conventional \textbf{search problem}.
  \end{quote}
\end{abstract}


\noindent 


\section{Technical Approach}

Compilers are the programs that convert written source code into executable code. Compilers, in general, are complex programs. In general, the compiler needs to break the source code into tokens\footnote{A token can be a keyword, a variable name, an operator, etc.} and represent it in a tree. Over this tree, the compiler performs some optimizations, such as removing unused variables and unreachable codes. After all this, the compiler can convert the tree into machine instructions.

The compiler must support all instructions provided by the programming language and be able to translate it for every operating systems. It is difficult to develop a compiler. In the proposed approach it will not be necessary to deal with all these complexities. The compiler will be formalized as a PDDL domain, with support for arithmetic and binary operations, functions and loop intructions.

In theory, this approach would work for all programming languages. However, I will create the actions and the predicates from the perspective of a source code written in C++.

There are still some questions to be answered during the execution of the project, as follows:

\begin{enumerate}
  \item Is the compiler domain capable of handling fluent variables and predicates?
  \item Is the compiler domain capable of performing operations with strings?
  \item Which planners should I test the compiler domain on?
  \item How does a planner find a parallel region?
  \item Can I set a weight for the planner to get regions that are really worth running in parallel?
\end{enumerate}


\section{Results Evaluation}

As previously described, the goal of the planner will be to execute all instructions in the correct order and find instructions that can be executed in parallel. Hence, to evaluate the correct output of the planner, I will map the predicates back to the source code and validate the parallel execution proposed by the planner.

The main objective of decoding the planner output in a source code is to test whether the parallel execution really brings positive results. A positive result, in the proposed approach, can be understood as the execution of a problem in less time.


\section{Project Management}

\begin{center}
  \begin{tabularx}{0.45\textwidth}{
      | >{\raggedright\arraybackslash}X
      | >{\raggedright\arraybackslash}X
      | >{\raggedright\arraybackslash}X|}
    \hline
    \textbf{Task}                 & \textbf{Start} & \textbf{End} \\
    \hline
    Understand better compilers   & 06-01-2020     & 06-03-2020   \\
    \hline
    Support sum instruction       & 06-03-2020     & 06-07-2020   \\
    \hline
    Support proposed instructions & 06-08-2020     & 06-15-2020   \\
    \hline
    Evaluate results              & 06-16-2020     & 06-20-2020   \\
    \hline
    Write paper                   & 06-20-2020     & 06-25-2020   \\
    \hline
  \end{tabularx}
\end{center}


\section{Conclusion}

In summary, this approach will reduce the problem of finding a parallel region to a \textbf{search problem}. As an output, the planner will execute all instructions of the program and identify the regions that can be executed in parallel. Clearly, these approach needs a validation in terms of testing to find out if the regions are really parallel.

The approach proposed in this paper is not conventional for finding parallel regions. However, if the results are positives, this approach can be used to reduce the time and cost to find these regions.


\bibliographystyle{aaai}
\bibliography{references}

\end{document}